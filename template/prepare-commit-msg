#!/usr/bin/env sh

file="$1"    # Points to current git file that contains the commit log message.
inputMethod="$2"    # From where commit process is triggered
#  - message:  -m or -F option was given
#  - template: -t option was given, or config option commit.template is set
#  - merge:    the commit is a merge or a .git/MERGE_MSG file exists
#  - squash:   .git/SQUASH_MSG file exists
#  - commit:   -c, -C or --amend option was given
# hash="$3"    # Third is hash - but it is not used

# Only act if the user is creating/editing a new commit message.
if [ -n "$inputMethod" ]; then
    exit 0
fi

lastCommitMessage="$(git log -1 --pretty=format:%s)"

removeAfterLast=':'
includeAfterLastSymbol='y'    # y/n
includeAfterLastSymbol=$(
  if [ 'n' = "$includeAfterLastSymbol" ]; then
    printf '%s' "$removeAfterLast"
  fi
)

# Remove everything after last occurence of `removeAfterLast`
lastCommitMessageHead="$(printf "%s" "$lastCommitMessage" |
  sed 's/'"$includeAfterLastSymbol"'[^'"$removeAfterLast"']*$//')"

# removeAfterFirst='>'

shortStatus="$(git status --porcelain=v1 --untracked-files='no')"

commentInShortStatus="$(printf '%s' "$shortStatus" | sed 's/^/# /')"

# branchname="$(git symbolic-ref -q HEAD | cut -f3 -d'/')"


### Main output

printf '# %s
# %s
# %s
' "$lastCommitMessageHead" "$lastCommitMessage" "$commentInShortStatus" > "$file"


exit 0
