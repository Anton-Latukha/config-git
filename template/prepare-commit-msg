#!/usr/bin/env dash

file="$1"    # Points to current git file that contains the commit log message.
inputMethod="$2"    # From where commit process is triggered
#  - message:  -m or -F option was given
#  - template: -t option was given, or config option commit.template is set
#  - merge:    the commit is a merge or a .git/MERGE_MSG file exists
#  - squash:   .git/SQUASH_MSG file exists
#  - commit:   -c, -C or --amend option was given
# hash="$3"    # Third is hash - but it is not used

# Only act if the user is creating/editing a new commit message.
if [ -n "$inputMethod" ]; then
    exit 0
fi

lastCommitMessages="$(git log --format=%s -2)"
removeAfterLast=':'
includeAfterLastSymbol='y'    # y/n
includeAfterLastSymbol=$(
  if [ 'n' = "$includeAfterLastSymbol" ]; then
    printf '%s' "$removeAfterLast"
  fi
)

# Remove everything after last occurence of `removeAfterLast`
lastCommitMessageHead="$(printf "%s" "$lastCommitMessages" |
  sed 's/'"$includeAfterLastSymbol"'[^'"$removeAfterLast"']*$//')"

# removeAfterFirst='>'

# Get status & file listing | Replace second char to space | Output only staged files.
filesStatus="$(git status --porcelain=v1 --untracked-files='no' | sed 's/./ /2' | rg '^\S')"

# commentInShortStatus="$(printf '%s' "$fileStatus" | sed 's/^/# /')"
# commentedInLastCommitMessages="$(printf '%s' "$lastCommitMessages" | sed 's/^/# /')"

# branchname="$(git symbolic-ref -q HEAD | cut -f3 -d'/')"


### Main output, sed comments the first N lines

printf '# %s
# %s
# %s
' "$lastCommitMessages" "$lastCommitMessageHead" "$filesStatus" > "$file"


exit 0
